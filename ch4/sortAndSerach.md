# 정렬과 탐색

---

- 효율적인 알고리즘 중 상당수는 입력 데이터를 정렬하는데 바탕을 두고 있는데, 이는 정렬을 수행함으로써 문제가 쉬워지는 경우가 많이 있기 때문이다.

### 1. 정렬 알고리즘

- 기본적으로 다뤄지는 정렬 문제는 다음과 같다.
- `원소 n개로 이루어진 배열이 주어질 때, 원소들을 크기가 증가하는 순서로 정렬하라.`

##### 버블 정렬

- 버블 정렬(Bubble sort)은 `O(n^2)` 시간에 동작하는 간단한 알고리즘이다.

1. n 번의 라운드로 이루어져 있으며, 라운드마다 배열의 원소를 한 번씩 쭉 살펴본다.
2. 연달아 있는 원소 두개의 순서가 잘못되어 있다는 것을 발견하면 두 원소를 맞바꾼다.

```c++
for(int i = 0 ; i<n;i++){
  for( int j=0;j<n-1;j++){
    if(array[j]>array[j+1]){
      swap(array[j],array[j+1]);
    }
  }
}
```

- 버블 정렬은 항상 배열에서 연달아 있는 원소만들 맞바꾸는 정렬 알고리즘의 예이다.

##### 병합 정렬

- 병합 정렬(Merge sort)은 `O(n log n)` 시간에 동작하는 알고리즘이다.
- 배열의 다른 위치에 있는 원소들의 순서를 바로 잡는 방식의 효율적인 알고리즘이다.

1. 만일 `a = b`라면 아무 것도 하지 않는다. 부분 배열이 원소 한 개로 이루어져 있으며, 이는 이미 정렬되어 있기 때문이다.
2. 가운데 원소의 위치를 `k = (a+b/2)`와 같이 계산한다.
3. **재귀적**으로 부분 배열 `array[a...k]`를 정렬한다.
4. **재귀적**으로 부분 배열 `array[k+1...b]`를 정렬한다.
5. 정렬된 부분 배열 `array[a..k]`와 `array[k+1...b]`를 병합하여 정렬된 부분 배열 `array[a...b]`로 만든다.

##### 계수 정렬

- 배열의 원소를 직접 비교하는 대신에 다른 정보를 이용하는 정렬 알고리즘에 대해서는 하한이 적용되지 않는다.
- 이 알고리즘은 배열의 모든 원소가 `0...c` 범위의 정수이며 `c=O(n)`일때 `O(n)`시간에 배열을 정렬하는 알고리즘이다.

##### 실제 상황에서의 정렬

- C++의 경우 sort 함수가 자료 구조의 내용물을 효율적으로 정렬한다.

```cpp
vector<int> v = {6,4,2,1,5,3,8};
sort(v.begin(),v.end());    //정렬
sort(v.rbegin(),v.rend());  //역순 정렬
```

- 일반적인 배열은 다음과 같이 정렬한다.

```cpp
int n = 7;  //배열의 크기
int a[] = {4,2,5,3,8,3};
sort(a,a+n);
```

- 다음은 문자열 s를 정렬하는 코드이다.

```cpp
string s = "Lake";
sort(s.begin(),s.end());
```

##### 비교 연산자

- sort함수를 사용하기 위해서는 정렬할 원소의 자료형에 대해 **비교연산자**가 정의되어 있어야한다.
- 대부분의 C++의 자료형에는 비교 연산자가 내장되어 있으며, 수는 값의 크기에 따라, 문자열은 알파벳순으로 정렬한다.
- 두 원소의 조합(pair)의 경우에는 먼저 첫 번째 원소를 기준으로 정렬하고 그 다음으로 두 번째 원소를 기준으로 정렬한다.

```cpp
vector<pair<int,int>> v;
v.push_back({1,5});
v.push_back({2,3});
v.push_back({1,2});
sort(v.begin(),v.end());
//결과 : [(1,2),(1,5),(2,3)]
```

- 이와 비슷하게 tuple의 경우에도 먼저 첫 번째 원소를 기준으로 정렬하고 두 번째, 세 번째 순으로 정렬한다.

##### 비교 함수

- 외부에 정의된 **비교 함수(Comparison function)** 를 sort 함수에 콜백 함수 형태로 줄 수도 있다.

```cpp
bool comp(string a, string b){
  if(a.size() == b.size()) return a<b;
  else return a.size() < b.size();
}
```

### 2. 정렬을 이용한 문제 풀이

- `O(n^2)` 시간에 쉽게 풀 수 있는 문제에 대한 `O(n)` 이나 `O(n log n)` 시간 알고리즘을 찾아내는 문제가 나올 수도 있다.

- 예를들어, 배열의 모든 원소가 유일한지 검사하려고 한다.

1. O(n&2)

```cpp
bool ok = true;
for(int i = 0 ; i < n ; i++){
  for(int j = i + 1 ; j < n ; j++){
    if(array[i] == array[j]) ok = false;
  }
}
//O(n^2)
```

2. O(n)

```cpp
bool ok = true;
sort(array,array+n);
for(int i = 0 ; i < n - 1 ; i++){
  if(array[i] == array[i+1]) ok = false;
}
// O(n)
```

### 3. 이진 탐색

- **이진 탐색(Binary search)** 은 정렬된 배열에 특정 원소가 존재하는지 여부를 파악하는 등의 문제를 `O(log n)`시간에 해결하는 알고리즘이다.

##### 이진 탐색 구현하기

1. 첫번째 방법

- 이진 탐색을 구현할 때 가장 많이 사용하는 방법은 사전에서 단어를 찾는 방법과 비슷하다.
- 탐색은 배열의 특정 부분 배열을 살펴보며 진행되며, 처음에는 배열 전체를 놓고 시작한다.
- 이후에는 단계별로 알고리즘을 진행해 나가면서 탐색 범위를 절반으로 줄여나간다.
- 단계마다 현재 살펴보고 있는 부분 배열 중앙의 원소를 검사한다.
- 만일 중앙 원소가 목표값과 같다면 탐색을 끝낸다.
- 그렇지 않으면 중앙 원소의 값에 따라 부분 배열의 왼쪽, 혹은 오른쪽 절반을 택하여 재귀적으로 탐색을 계속해 나간다.

```cpp
int a = 0, b = n-1;
while( a <= b){
  int k = (a+b)/2;
  if(array(k) == x){
    // 위치 k에 x를 찾음
  }
  if( array[k] < a) a = k+1;
  else b = k-1;
}
```

- 이 구현 방법은 범위 `a...b`의 부분 배열을 살펴보게 되어 있으며, 시작할 때의 범위는 `0...n-1`이다.
- 알고리즘이 단계마다 부분 배열의 크기를 절반씩 줄여나가기 때문에 시간 복잡도는 `O(log n)`이다.

2. 두 번째 방법

- 이진 탐색을 구현하는 또 다른 방법은 배열을 왼쪽에서 오른쪽으로 건너뛰어 가며 살펴보는 것이다.
- 처음에는 `n/2`개의 원소를 건너뛴다.
- 라운드마다 건너뛸 원소 수를 `n/2`,`n/4`,`n/8`과 같은 식으로 절반씩 줄여나가면서 1이 될 때까지 진행한다.
- 각 라운드에서는 원소를 계속 건너뛰는데, 원소를 건너뜀으로써 배열의 범위를 벗어나거나, 건너뛴 후의 원소가 목표 값을 벗어난다면 건너뛰지 않고 멈춘다.
- 이처럼 진행하고 나면 찾고자 하는 원소에 도달하게 되고, 그렇지 않다면 배열에 원소가 존재하지 않는 다는 것을 알 수 있다.

```cpp
int k = 0;
for(int b = n/2 ; b > = 1 ; b /= 2){
  while(k+b < n && array[k+b] <= x) k += b;
}
if(array[k] == x){
  // 위치 k에서 x를 찾음
}
```

- 위의 알고리즘의 시간 복잡도도 `O(log n)`인데, 코드 안의 `while` 반복문이 같은 `b`에 대해 최대 두 번만 수행되기 때문이다.
