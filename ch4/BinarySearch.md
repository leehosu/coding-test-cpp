# 이진 탐색

---

> **이진 탐색(Binary search)** 은 정렬된 배열에 특정 원소가 존재하는지 여부를 파악하는 등의 문제를 `O(log n)`시간에 해결하는 알고리즘이다.

##### 이진 탐색 구현하기

1. 첫번째 방법

- 이진 탐색을 구현할 때 가장 많이 사용하는 방법은 사전에서 단어를 찾는 방법과 비슷하다.
- 탐색은 배열의 특정 부분 배열을 살펴보며 진행되며, 처음에는 배열 전체를 놓고 시작한다.
- 이후에는 단계별로 알고리즘을 진행해 나가면서 탐색 범위를 절반으로 줄여나간다.
- 단계마다 현재 살펴보고 있는 부분 배열 중앙의 원소를 검사한다.
- 만일 중앙 원소가 목표값과 같다면 탐색을 끝낸다.
- 그렇지 않으면 중앙 원소의 값에 따라 부분 배열의 왼쪽, 혹은 오른쪽 절반을 택하여 재귀적으로 탐색을 계속해 나간다.

```cpp
int a = 0, b = n-1;
while( a <= b){
  int k = (a+b)/2;
  if(array(k) == x){
    // 위치 k에 x를 찾음
  }
  if( array[k] < a) a = k+1;
  else b = k-1;
}
```

- 이 구현 방법은 범위 `a...b`의 부분 배열을 살펴보게 되어 있으며, 시작할 때의 범위는 `0...n-1`이다.
- 알고리즘이 단계마다 부분 배열의 크기를 절반씩 줄여나가기 때문에 시간 복잡도는 `O(log n)`이다.

2. 두 번째 방법

- 이진 탐색을 구현하는 또 다른 방법은 배열을 왼쪽에서 오른쪽으로 건너뛰어 가며 살펴보는 것이다.
- 처음에는 `n/2`개의 원소를 건너뛴다.
- 라운드마다 건너뛸 원소 수를 `n/2`,`n/4`,`n/8`과 같은 식으로 절반씩 줄여나가면서 1이 될 때까지 진행한다.
- 각 라운드에서는 원소를 계속 건너뛰는데, 원소를 건너뜀으로써 배열의 범위를 벗어나거나, 건너뛴 후의 원소가 목표 값을 벗어난다면 건너뛰지 않고 멈춘다.
- 이처럼 진행하고 나면 찾고자 하는 원소에 도달하게 되고, 그렇지 않다면 배열에 원소가 존재하지 않는 다는 것을 알 수 있다.

```cpp
int k = 0;
for(int b = n/2 ; b > = 1 ; b /= 2){
  while(k+b < n && array[k+b] <= x) k += b;
}
if(array[k] == x){
  // 위치 k에서 x를 찾음
}
```

- 위의 알고리즘의 시간 복잡도도 `O(log n)`인데, 코드 안의 `while` 반복문이 같은 `b`에 대해 최대 두 번만 수행되기 때문이다.
