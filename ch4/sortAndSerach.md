# 정렬 알고리즘

---

- 기본적으로 다뤄지는 정렬 문제는 다음과 같다.
- `원소 n개로 이루어진 배열이 주어질 때, 원소들을 크기가 증가하는 순서로 정렬하라.`

##### 버블 정렬

- 버블 정렬(Bubble sort)은 `O(n^2)` 시간에 동작하는 간단한 알고리즘이다.

1. n 번의 라운드로 이루어져 있으며, 라운드마다 배열의 원소를 한 번씩 쭉 살펴본다.
2. 연달아 있는 원소 두개의 순서가 잘못되어 있다는 것을 발견하면 두 원소를 맞바꾼다.

```c++
for(int i = 0 ; i<n;i++){
  for( int j=0;j<n-1;j++){
    if(array[j]>array[j+1]){
      swap(array[j],array[j+1]);
    }
  }
}
```

- 버블 정렬은 항상 배열에서 연달아 있는 원소만들 맞바꾸는 정렬 알고리즘의 예이다.

##### 병합 정렬

- 병합 정렬(Merge sort)은 `O(n log n)` 시간에 동작하는 알고리즘이다.
- 배열의 다른 위치에 있는 원소들의 순서를 바로 잡는 방식의 효율적인 알고리즘이다.

1. 만일 `a = b`라면 아무 것도 하지 않는다. 부분 배열이 원소 한 개로 이루어져 있으며, 이는 이미 정렬되어 있기 때문이다.
2. 가운데 원소의 위치를 `k = (a+b/2)`와 같이 계산한다.
3. **재귀적**으로 부분 배열 `array[a...k]`를 정렬한다.
4. **재귀적**으로 부분 배열 `array[k+1...b]`를 정렬한다.
5. 정렬된 부분 배열 `array[a..k]`와 `array[k+1...b]`를 병합하여 정렬된 부분 배열 `array[a...b]`로 만든다.

##### 계수 정렬

- 배열의 원소를 직접 비교하는 대신에 다른 정보를 이용하는 정렬 알고리즘에 대해서는 하한이 적용되지 않는다.
- 이 알고리즘은 배열의 모든 원소가 `0...c` 범위의 정수이며 `c=O(n)`일때 `O(n)`시간에 배열을 정렬하는 알고리즘이다.

##### 실제 상황에서의 정렬

- C++의 경우 sort 함수가 자료 구조의 내용물을 효율적으로 정렬한다.

```cpp
vector<int> v = {6,4,2,1,5,3,8};
sort(v.begin(),v.end());    //정렬
sort(v.rbegin(),v.rend());  //역순 정렬
```

- 일반적인 배열은 다음과 같이 정렬한다.

```cpp
int n = 7;  //배열의 크기
int a[] = {4,2,5,3,8,3};
sort(a,a+n);
```

- 다음은 문자열 s를 정렬하는 코드이다.

```cpp
string s = "Lake";
sort(s.begin(),s.end());
```

##### 비교 연산자

- sort함수를 사용하기 위해서는 정렬할 원소의 자료형에 대해 **비교연산자**가 정의되어 있어야한다.
- 대부분의 C++의 자료형에는 비교 연산자가 내장되어 있으며, 수는 값의 크기에 따라, 문자열은 알파벳순으로 정렬한다.
- 두 원소의 조합(pair)의 경우에는 먼저 첫 번째 원소를 기준으로 정렬하고 그 다음으로 두 번째 원소를 기준으로 정렬한다.

```cpp
vector<pair<int,int>> v;
v.push_back({1,5});
v.push_back({2,3});
v.push_back({1,2});
sort(v.begin(),v.end());
//결과 : [(1,2),(1,5),(2,3)]
```

- 이와 비슷하게 tuple의 경우에도 먼저 첫 번째 원소를 기준으로 정렬하고 두 번째, 세 번째 순으로 정렬한다.

##### 비교 함수

- 외부에 정의된 **비교 함수(Comparison function)** 를 sort 함수에 콜백 함수 형태로 줄 수도 있다.

```cpp
bool comp(string a, string b){
  if(a.size() == b.size()) return a<b;
  else return a.size() < b.size();
}
```
