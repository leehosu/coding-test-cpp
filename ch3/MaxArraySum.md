# 최대 부분 배열 합

---

- 배열에 수 n개가 들어 있을 때 **최대 부분 배열 합**을 구하는 문제이다.
- 즉, 배열에서 연속해 있는 값들을 택하여 그 합을 최대로 만드는 것이다.

### O(n^3) 시간 풀이

- 이 문제를 푸는 직관적인 방법은 가능한 모든 부분 배열을 하나씩 살펴보고, 그 부분 배열의 합을 구한 후, 최대 합을 관리하는 것이다.

```c++
int best = 0;
for(int a=0;a<n;a++){
  for(int b = a; b<n;b++){
    int sum = 0;
    for( int k = a; k<=b ; k++){
      sum += array[k];
    }
    best = max(best,sum);
  }
}
cout << best <<"\n";
```

- 변수 a와 b는 부분 배열의 첫 번째 위치와 마지막 위치를 나타낸다.
- 부분 배열의 합을 계산하여 변수 sum에 저장한다.
- 변수 best에는 답을 구하는 과정에서 찾은 최대 합을 기록한다.

### O(n^2) 시간 풀이

```c++
int best = 0;
for( int a = 0 ; a < n ; a++){
  int sum = 0;
  for( int b = a; b<n; b++){
    sum += array[b];
    best = max(best,sum);
  }
}
cout<< best << "\n";
```

- 앞선 알고리즘에서 반복문 하나를 줄여서 더 효율적인 알고리즘을 만들었다.

### O(n) 시간 풀이

- 배열의 각 위치에 대해 그 위치에서 끝나면서 합이 최대인 부분 배열을 계산해 나가는 것이다.
- 그러면 계산한 합 중에 최대를 구하여 문제의 답을 구할 수 있다.

1. 부분 배열이 위치 k의 원소 하나만으로 이루어진 경우
2. 위치 k - 1에서 끝나는 부분 배열에 위치 k의 원소를 덧붙여 부분 배열을 만드는 경우
   -> 배열 왼쪽에서 오른쪽으로 살펴보면서, 각 위치에서 끝나는 최대 부분 배열 합을 계산하면 된다.

```c++

int best = 0, sum = 0;
for(int k = 0;k<n k++){
  sum = max(array[k], sum + array[k]);
  best = max(best,sum);
}
cout << best << "\n";
```
