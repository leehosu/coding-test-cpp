# 시간 복잡도

---

- 알고리즘의 **시간복잡도**는 입력에 대해 알고리즘이 얼마만큼의 시간을 사용할지를 근사적으로 알려준다.
- 시간 복잡도를 계산해보면, 알고리즘을 구하현하지 않고도 문제를 풀 마큼 알고리즘의 속도가 빠른지 여부를 알 수 있다.
- 시간 복잡도는 `O(...)`으로 표기하며, 괄호안에는 함수가 들어간다.

##### 계산 규칙

- 만일 코드가 단일 명령어로만 구성되어 있다면 시간 복잡도는 `O(1)`이다.

```c++
a++;
b++;
c = a_b;
```

- 반복문의 시간 복잡도는 반복문 안의 내용이 몇번 수행되는지를 근사적으로 알려준다.

```c++
for(int i=0;i<n;i++){
  ...
}
//O(1)

for(int i=0;i<n;i++){
  for(int j=0;j<n;j++){
    ...
  }
}
//O(n^2)

for(int i = 1;i<3*n;i++){
  ... //3n번 수행
}
//O(n)

for(int i = 1;i<n+5;i++){
  ...//n+5번 수행
}
//O(n)

for(int i=1;i<n;i+=2){
  ...// n/2번 수행
}
//O(n)
```

- 시간 복잡도가 반복문 배누 코드의 수행 횟수를 정확하게 알려주지는 않는다.
- 이는 시간 복잡도에서 함수의 차수만 중요하고 상수 인자는 무시되기 때문이다.

<br/>

- 만일 알고리즘이 여러 단계가 연달아 있는 형태로 구성되어 있다면, 전체 시간 복잡도는 각 단계의 시간 복잡도 중에서 제일 큰 것이 된다.
- 그 이유는 가장 느린 단계가 알고리즘의 **병목**되기 때문이다.

<br/>

- 시간 복잡도가 여러 인자에 영향을 받을 때도 있으며, 그럴 때는 시간 복잡도 함수에 여러 변수가 포함된다.

```c++

for(int i=1;i<=n;i++){
  for(int j=1;j<=m;j++){
    ...
  }
}
//O(nm)
```

##### 재귀 함수

- 재귀 함수의 시간 복잡도는 함수가 몇 번 호출되는지, 그리고 각 호출 때의 시간 복잡도가 어떻게 되는지에 따라 결정된다.

```c++
void f(int n){
  if(n==1) return;
  f(n-1);
}
//O(n)
```

- f(n)을 수행하면 함수 호출이 n번 발생하고, 각 호출의 시간 복잡도는 `O(1)`이다. 따라서 전체 시간 복잡도는 `O(n)`이다.

```c++
void g(int n){
  if(n==1) return;
  g(n-1);
  g(n-1);
}
//O(2^n)
```

- 인자를 `n`으로 주고 이 함수를 호출하면 인자가 `n-1`인 함수 호출이 두 번 일어나고, 인자가 `n-2`인 함수 호출은 4번 일어나며, 인자가 `n-3`인 함수 호출은 8번일어나며 이러한 과정이 계속 진행된다.
- 즉, 인자가 `n-k`인 함수 호출은 `2^k`번 일어나고 이때 `k=0,1,...,n-1`이다. -따라서 시간 복잡도는 `1+2+4+8+...+2^n-1=2^n-1=O(2^n)`이다.

### 예제 문제

- ##### [최대 부분 배열합](https://github.com/leehosu/coding-test-cpp/blob/master/ch3/MaxArraySum.md)
